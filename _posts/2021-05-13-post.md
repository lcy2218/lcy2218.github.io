---
layout: post
title:  OSPF协议(多区域)
date: 2021-05-13 22:20 +0900
category: routing-theory
---
<!-- TOC -->

- [0x0 WHY OSPF需要使用多区域?](#0x0-why-ospf需要使用多区域)
  - [0x0.1 单区域的问题](#0x01-单区域的问题)
  - [0x0.2 OSPF多区域](#0x02-ospf多区域)
- [0x1 HOW OSPF使用多区域?](#0x1-how-ospf使用多区域)
  - [0x1.1 多区域基本概念](#0x11-多区域基本概念)
  - [0x1.2 一些问题](#0x12-一些问题)
  - [0x1.2 OSPF的六类LSA](#0x12-ospf的六类lsa)
  - [0x1.3 OSPF的七种状态](#0x13-ospf的七种状态)
- [0x2 WHAT OSPF使用多区域的结果?](#0x2-what-ospf使用多区域的结果)

<!-- /TOC -->
## 0x0 WHY OSPF需要使用多区域?

设计OSPF之初,希望OSPF工作在大型局域网内,但是工作在大型局域网内,单区域会参数很多问题

### 0x0.1 单区域的问题

- LSDB庞大,占用内存大
- LSA洪范范围大,拓扑变化影响大
- 路由不能被汇总,路由表庞大

### 0x0.2 OSPF多区域

- 如何解决LSDB区域太大?
- 每个区域只收集自己区域的LSDB
- 只收集自己区域的LSDB,只能计算自己区域内的路由,区域间如何学习?

## 0x1 HOW OSPF使用多区域?

OSPF通过骨干区域和非骨干区域交换各类LSA来实现多区域的OSPF路由

### 0x1.1 多区域基本概念

- ABR:区域边界路由器,同时工作在多个区域内,可以收集并且计算多个区域的路由信息,然后跨区域传递这些路由信息
- ASRB:自治系统边界路由器,某个路由器
  1. **既运行了OSPF,又运行了其他来源**
  2. **将其他来源学到的路由发布进了OSPF中**

- 为了区域间无环
  - OSPF对区域进行了定义,定义了**骨干区域(area 0)**和**非骨干区域**
    - 部署的时候,以骨干区域为核心,其他区域只能直接和骨干区域相连
    - 非骨干区域之间不能直接进行路由的交换

### 0x1.2 一些问题

- ABR一定工作在area 0?
  - 是的,非骨干区域不能直接相连,非骨干区域只能和骨干区域相连,ABR可以同时工作在多个区域,所以ABR一定工作在area 0

- 重发布是什么意思?
  - 重发部某个路由器将其他来源学到的路由发布到自己的这个协议进程中

- 某个路由器,既运行了OSPF,又运行了RIP,这个路由器是不是ASBR?
  - 不是,需要将其他来源学到的路由器发布出去,否则不是ASBR

- OSPF维护路由和更新路由的机制?
  - 维护:对邻居表进行维护,邻居关系是好的,从该邻居学到的路由就是正常的,通过LSDB维护
  - 更新:直接发LSU,路由失效了或者学习新的路由

- LSA的收敛?
  - 为了防止LSA占用OSPF进程的内存资源,会进行收敛
  - 主动老化:
    - 某个网段失效了,路由器会马上给自己的邻居发LSU,通知老化LSA
  - 被动老化:
    - 如果通信中断,导致LSU无法到达,该被老化的LSA长期存在对方的LSDB中,浪费内存资源,
    - 给每个LSA设置了一个LS age,描述这个LSA诞生开始到目前位置经过的时间,每隔1800s会对LSA进行一次更新,更新成功LS age刷新,更新失败后,当某个LS - - age达到3600S后会被LSDB删除

### 0x1.2 OSPF的六类LSA

![](/images/20210513-1.png)
- LSA1:描述路由器直连拓扑信息,发出者OSPF路由器
- LSA2:描述广播多路访问DR邻接的一组路由器,发出者DR
  - **注1:P2P只有LSA1(因为P2P不需要建立DR和BDR)**
  - **注2:LSA1,LSA2描述的是拓扑信息**
- LSA3:**描述区域间路由**(将自己再区域内算出的路由发给骨干区域,将骨干区域的路由算出来发给自己区域),描述的路由信息,发出者ABR
- LSA4:**描述外部区域的可达性**(本区域的ABR描述到ASBR的开销),描述的是拓扑信息,发出者ABR
- LSA5:**描述OSPF外部路由**(ASRB描述到外部区域的开销),描述路由信息,发出者ASBR
- LSA7:**只存在NSSA区域内**,由ASBR发出,描述外部路由(类似LSA5)

- 总结
  - 区域内：
    - 通过传递LSA1和LSA2，传递的是拓扑信息，完成LSDB的同步，再计算路由
  - 区域间：
    - 通过ABR计算出某区域的路由后，用LSA3描述，发布进另一个区域，描述去往其他区域的路由
  - 外部路由：
    - 通过ASBR传递LSA5，发布外部路由，携带外部路由的开销，描述去往OSPF外部的路由
    - ABR发出LSA4，每个区域进行传递(首先由ASBR所在区域的ABR发起，通过连接其他网段的ABR进行传递)，描述出去往ASBR的内部开销
      - 每个区域都可以根据自己区域的ABR算出去ASBR的内部开销

### 0x1.3 OSPF的七种状态

- 邻居关系与邻接关系
  - **邻居关系:能够建立邻居,但不直接交换LSDB,通过DR交换**
  - 2-way是邻居的最终关系(例如两个DROther)-------->同步完LSDB后,才叫做full状态
  - **邻接关系:需要直接交换LSDB**
  - 注:邻居状态是指**这个路由器和某个邻居**的关系,并非单独指自己

  1. Down状态:Down也算一种邻居关系,(如果A路由器的直连B路由器未跑OSPF,A无法发现B,不算down状态)
     - A收到B的hello报文后,先判断能够建立邻居
     - A在自己的邻居表内和B的关系设为Init或者2-way
       1. 判断能否建立邻居?
       2. A会看**B发来的Hello报文中的邻居表**,看邻居表中有没有自己;
          - 邻居表内有自己,说明B在发这个hello包前,已经**发现自己了**,此时关系为**2-way**
          - 邻居表内没有自己,说明B再发这个hello之前,**没有发现我**,此时关系为**init**
  2. Init状态:能建立邻居,但路由器**认为对方还没发现自己**
  3. 2-way状态:能建立邻居,但路由器**认为对方已经发现自己**
  **以上三种状态迁移都是通过hello包**  
  4. Exstart状态:开始准备邻接关系迁移
     1. 先交换DD报文,选出**主从路由器**
        - 依照序列号选主从
     1. 选出之后进入Exchange状态
     2. 从路由器对主路由器的DD报文进行响应,响应一个DD报文,响应报文的**序列号与主路由器的一致**(表示我认为你是主路由器了)
     3. 之后从路由器对主路由器响应的DD报文的序列号每次都需一致
     > OSPF为了保障DD报文的可靠性,需要选出主从,Broadcast和P2P都要选主从  

  1. Exchange状态:
     1. 交换DD报文,交换LSDB的汇总
     2. LSDB相同时,进入FULL状态
  2. FULL状态:两个路由器的LSDB已经相同------->邻接关系的最终稳定状态
  3. LOADING状态:使用LSR、LSU、LSACK进行同步,最终进入邻接关系

## 0x2 WHAT OSPF使用多区域的结果?

- OSPF使用多区域后解决了OSPF单区域产生的问题
**OSPF 区域内无环;区域间拓扑无环**

